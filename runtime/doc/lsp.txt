*lsp.txt* The Language Server Protocol

        NVIM REFERENCE MANUAL


Neovim Language Server Protocol (LSP) API

Neovim exposes a powerful API that conforms to Microsoft's published Language
Server Protocol specification. The documentation can be found here:

	https://microsoft.github.io/language-server-protocol/


================================================================================
                                                            *lsp-server-config*

Neovim only exposes a powerful API for the language server protocol. To get
the real benefits of this API, a language server must be installed. Many
examples can be found here:

	https://microsoft.github.io/language-server-protocol/implementors/servers/

After installing a language server to your machine, you must let Neovim know
how to start and interact with that language server. To do so, use the
following APIs:

                                                      *lsp#add_server_config()*
lsp#add_server_config({config}):
	Used to add a language server.

	This will add an autocmd that will start the server and handle any other
	startup activities whenever the |FileType| event is triggered for {ftype}.

	Parameters: ~
		{config} (dictionary): 
			`filetype` (string|array):
				A string or list of strings of filetypes to
				associate with this server.

			`server_name` (string) (optional):
				You can pass any name as server_name.
				If you want to use multiple language servers
				for one filetype, be sure to add server_name.

			`cmd` (dictionary): Executing language server command.
				`execute_path` (string):
					Executing language server command path.
				`args` (array):
					Command arguments.

			`server_config` (dictionary): Optional configuration for a server.

	Example: ~
>
		" C, C++ example
		call lsp#add_server_config(
		      \ 'filetype': ['c', 'cpp'],
		      \ 'server_name': 'cland',
		      \ 'cmd': { 'execute_path': 'cland', 'args': ['-background-index'] })
<
>
		" Go example
		call lsp#add_server_config(
		      \ 'filetype': 'go',
		      \ 'server_name': 'gopls',
		      \ 'cmd': { 'execute_path': 'gopls', 'args': [] })
<
>
		" Python example
		call lsp#add_server_config(
		      \ 'filetype': 'python',
		      \ 'server_name': 'pyls',
		      \ 'cmd': { 'execute_path': 'pyls', 'args': [] })
<
>
		" Rust example
		call lsp#add_server_config(
		      \ 'filetype': 'rust',
		      \ 'server_name': 'rls',
		      \ 'cmd': { 'execute_path': 'rustup', 'args': ['run', 'stable', 'rls'] },
		      \ 'server_config': {
		      \   'clippy_preference': 'on',
		      \   'all_targets': v:false,
		      \   'build_on_save': v:true,
		      \   'wait_to_build': 0
		      \ })
<

================================================================================
                                                                  *lsp-request*
Requests

To make a request to the language server client running in Nvim, the following
API is defined:
>
	:lua vim.lsp.request(method, arguments, callback, bufnr, filetype)
	:lua vim.lsp.request_async(method, arguments, callback, bufnr, filetype)
<

                                                            *vim.lsp.request()*
vim.lsp.request({method} [, {arguments} [, {callback} [, {bufnr} [, {filetype} [, {server_name}]]]]]):
	Creates and sends a request to the server for [filetype]. Will fill in any
	missing required arguments as defined by the language server protocol. Will
	call the built-in callback for the request (if you set that and it exists), unless an
	[callback] is specified, in which case that will be called upon completion
	of the request.

	Returns the request's response data.

	Parameters: ~
		{method}: The name of the request, as specified by the
		language server protocol.
			Example: 'textDocument/hover'

		{arguments}: The arguments that should be passed to the language
		server. If any required keys are missing, Nvim will fill those in
		with reasonable default values.
			Example (with 'textDocument/hover'):
				Passed in:
					{} or |v:null|

				Sent:

					{
					    'textDocument': '/home/user/test/example.lua',
					    'position': { 'line': 13, 'character': 17 }
					}

		{callback}: An optional callback that will be executed
			once the response has been received. If this is passed and not
			|v:null|, then the |lsp-built-in-callback| will not be executed for
			this request. If you do not set |built-in-callbacks| or this request does not have a
			specific filetype callback, then no callback will be executed upon receiving the request.

			The callback must be a string with the name of the vimscript
			function to call. The signature must be:

				`func_name({success}, {data})`

			where {success} is a boolean where true means successful request
			and false means the request failed.

			The parameter {data} is a dictionary containing the possible
			response data (or error) as specified by the language
			server protocol.

			The callback will be executed from Lua running:

				`vim.api.nvim_call_function('func_name', { success, data })`

		{bufnr}: The number of the buffer.
			This is used for used as an application destination for processing.

		{filetype}: The filetype associated with the server.
			This will default to the current |filetype| if nothing is passed.

		{server_name}: The server name associated with the server.
			This will default to the same value of |filetype|.

		Configuration for the default server can be found at |lsp-configuration|.

                                                      *vim.lsp.request_async()*
vim.lsp.request_async({method} [, {arguments} [, {callback} [, {bufnr} [, {filetype} [, {server_name}]]]]]):
	Creates and sends a request to the server for [filetype].
	This request will not block and will call the desired [callback] upon completion.

	Returns the request ID.

	See |vim.lsp.request()| for more information.

	Example: ~
>
		:lua vim.lsp.request_async('textDocument/hover', vim.lsp.protocol.TextDocumentPositionParams())
<
================================================================================
                                                        *lsp-built-in-callback*

The following requests have built-in callbacks defined to handle the response
in an idiomatic way.

	textDocument/completion
	textDocument/hover
	textDocument/signatureHelp
	textDocument/definition

vim.lsp.config.set_all_builtin_callbacks()
	You can enable all built-in callbacks

vim.lsp.config.set_builtin_callback({method})
	You can enable a specific built-in callback.
		Parameters: ~
			{method}: The name of the request, as specified by the
				language server protocol.
		Example: ~
			'textDocument/hover'

vim.lsp.config.set_builtin_callbacks({methods})
	You can set specific built-in callbacks.
		Parameters: ~
			{method}: The name of the request, as specified by the
				language server protocol.
		Example: ~
			{'textDocument/hover', 'textDocument/publishDiagnostics'}

================================================================================
                                                          *lsp-common-behavior*

Many of the Language Server Protocol messages are similar to common commands
in nvim. Here are some example configurations that could integrate LSP into
your daily workflow.

textDocument/definition~
	This is essentially "go-to definition". Since this is generally done
	through tags, the following mapping might be considered idiomatic.
>
	nnoremap <silent> <Leader>d :lua vim.lsp.request_async('textDocument/definition', vim.lsp.protocol.TextDocumentPositionParams())<CR>
<
	or
>
	nnoremap <buffer> <Leader>d :call lsp#text_document_definition()<CR>
<

================================================================================
                                                            *lsp-configuration*

g:language_client_log_level
	You can set the log level for language client logging.
	debug, info, warn, error, none.

	Default: none

================================================================================
                                                               *lsp-completion*

To configure completion for a language server, add the following in your
init.vim:
>
	call luaeval("require('vim.lsp.config').set_builtin_callback('textDocument/completion')")
	augroup MyLanguageServer
		au!
		autocmd Filetype python inoremap <buffer> <c-n> <c-r>=lsp#text_document_completion()<CR>
	augroup END
<
================================================================================
                                                                    *lsp-hover*

To configure hover for a language server, add the following in your
init.vim:
>
	call luaeval("require('vim.lsp.config').set_builtin_callback('textDocument/hover')")
	augroup MyLanguageServer
		au!
		autocmd Filetype python nnoremap <silent> <Leader>h :call lsp#text_document_hover()<CR>
	augroup END
<
================================================================================
                                                           *lsp-signature-help*

To configure signature help for a language server, add the following in your
init.vim:
>
	call luaeval("require('vim.lsp.config').set_builtin_callback('textDocument/signatureHelp')")
	augroup MyLanguageServer
		au!
		autocmd Filetype python nnoremap <silent> <Leader>sh :call lsp#text_document_signature_help()<CR>
	augroup END
<
================================================================================
                                                               *lsp-definition*

To configure definition for a language server, add the following in your
init.vim:
>
	call luaeval("require('vim.lsp.config').set_builtin_callback('textDocument/definition')")
	augroup MyLanguageServer
		au!
		autocmd Filetype python nnoremap <silent> <Leader>d :call lsp#text_document_definition()<CR>
	augroup END
<
================================================================================
                                                           *lsp-handle-request*

The callbacks used to handle the responses and requests of the language server
protocol are exposed to users of Neovim to allow them to replicate these
actions easily and idiomatically.

For example, if a plugin author wants to replicate the hover functionality of
"textDocument/hover" without wanting to maintain an implementation and cater
to various users configuration preferences, the author of the plugin may use
the Neovim's built-in LSP callbacks to perform the hovering action.

To do so, the following APIs are provided:

	In Vim script, use:
>
		call luaeval("vim.lsp.handle({request}, {data})")
<

                                                             *vim.lsp.handle()*
vim.lsp.handle({request}, {data})
	Used to provide API access to Neovim's language server protocol
	implementation.

	Parameters: ~
		{request}: The name of the request, i.e. 'textDocument/hover'

		{data}: A dictionary containing the data that would normally be in the
		response section for the particular {request}.
	
	Example: ~
>
		" Display "Hello", "World" on two lines
		call luaeval("vim.lsp.handle('textDocument/hover', {'content': ['Hello', 'World']})")

vim:tw=78:ts=8:ft=help:norl:
